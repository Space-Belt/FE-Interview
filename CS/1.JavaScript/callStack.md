# 콜스택(호출 스택) ?

> [mdn](https://developer.mozilla.org/ko/docs/Glossary/Call_stack) 에서는 여러 함수들을 호출하는 스크립트에서 해당 위치를 추적하는 인터프리터를 위한 메커니즘이며. 현재 어떤 함수가 동작하고 있는지, 그 함수 내에서 어떤 함수가 동작하는지, 다음에 어떤 함수가 호출되어야하는지 등을 제어한다고 한다.

<br/>

## 인터프리터가 뭔지 모르니 인터프리터와 컴파일을 같이 알아보자!

<br/>

> <h3> 인터프리터?

프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경이라고 한다.

자바스크립트는 웹 브라우저에 포함되어있는 자바스크립트 인터프리터가 소스코드를 직접 해석해서 바로 실행한다

원시코드를 기계어로 번역하는 컴파일러와는 대비된다.

> <h3> 컴파일?

사람이 작성한 소스 코드를 컴퓨터가 이해할 수있는 기계어 (목적 코드) 로 해석(번역)하는 작업 방식이다.

> <h3> 그렇다면 인터프리터와 컴파일의 차이는?

**컴파일**

> **인터프리터**

- 컴파일러는 프로그램 전체 번역 후 실행한다.
- 번역 후 저장을 위해 목적 코드를 출력한다.
- 처음엔 느리지만 목적 코드를 저장하고 이용하므로 이후에는 실행이 빠르다.

> **실행과정**

1. 어휘 분석
   - 원시 코드를 토큰으로 나눔
2. 구문 분석
   - 토큰이 문법적으로 옳은지 검사
   - 오류 없으면 구문 트리 생성
3. 중간 코드 생성
   - 기계어와 유사한 중간 코드로 된 프로그램 생성
   - 문법적인 error가 아닌 의미적 error 검사
4. 최적화
   - 중간코드 좀 더 효율적으로 개선
   - 크기 낮추고 실행 속도 올려줌
5. 코드생성
   - 목적 프로그램 생성

- 프로그램을 1줄 씩 번역한다.출력물 없이 매번 즉시 실행한다.
- 컴파일 과정이 없으므로 크기가 큰 원시코드도 비교적 실행이 빠르다.
- 대화식 프로그래밍으로 쉬운 접근이 가능하다
- 메모리가 적다

> **실행과정**

1. 명령어 한줄을 메모리에서 가져옴
2. 가져온 명령어를 해석
3. 필요한 데이터를 가져옴
4. 명령을 실행

---

> <h2> 이해를 위해 메모리 구조 원리에 알아보자!

컴퓨터의 모든 프로그램이 실행되기 위해서 일단 프로그램이 메모리 공간에 이동해야한다.

따라서 프로그램에서 사용되는 변수들을 저장할 메모리도 필요하다. **\*운영체제**는 프로그램을 실행하기 위해 다양한 메모리 공간을 확보하고 있다.

<b>\*운영체제란?</b> 사용자의 하드웨어, 시스템 리소스를 제어하고 프로그램에 대한 일반적 서비스를 지원하는 시스템 소프트웨어

![메모리](https://user-images.githubusercontent.com/82592845/181215404-7f48234b-6ac4-4e33-a62c-b908dc58ad2b.png)

> <h2> 코드 영역 ( Code Area )

<br />

우리가 코드를 타이핑할때 코드창에 렌더링 되는 부분이다.

코드 영역은 실행 파일을 수행하는 명령어들이 메모리 공간 쪽으로 제어문, 함수, 상수 등이 지정된다.

<br />

> <h2> 데이터 영역 ( Data Area )

<br />

전역 변수와 정적 변수를 할당하여 저장하는 영역이다.

이 영역은 Read-Write로 설정되어 있는데 실행 중 변수가 변경될 수도 있기 때문이다.

프로그램의 시작을 통해 할당되며, 종료시 메모리가 소멸된다.

<br />

> <h2> 힙 영역 ( Heap Area )

<br />

프로그래머가 직접 할당/해제 하는 메모리 영역이다.

힙 영역은 메모리의 낮은 주소부터 높은 주소까지 올라가는 절차 형식으로 할당된다.

- 자바스크립트에서 heap은 **객체, 배열, 함수와 같이 크기가 동적으로 변할 수 있는 참조타입 값을 저장**한다.

<br />

> <h2> 스택 영역 ( Stack Area )

<br />

함수의 호출 시 지역 변수와 매개 변수가 저장되는 임시 메모리 영역이다.

이때 스택 영역은 **메모리의 높은 주소부터 낮은 주소(LIFO 후입 선출)까지 내려가는 절차 형식**으로

할당되는데, 여기서 스택 영역에 저장되는 함수의 호출 정보를 stack frame이라고 한다.

함수 호출이 완료되면 스택 영역의 함수 정보들은 소멸된다.

자바스크립트에서 **call stack은 정적으로 간단히 값들만 할당된 변수들도 저장**이 된다

<br/>
<br/>

# 이제 자바스크립트 엔진을 알아보자

<br/>

우리가 접하기 쉬운 자바스크립트의 엔진은 구글의 V8 엔진이다. V8 엔진은 크롬과 노드안에서 작동한다. 자바스크립트 엔진은 **두가지 주요 구성 요소**로 이루어져 있다!

**메모리 힙** 과 **호출스택** 이다

<br/>

![메모호출](https://user-images.githubusercontent.com/82592845/181218267-f28dcaaa-bb58-4d86-acb9-62cb44453b11.png)

<br/>

> <h2>메모리 힙

<br/>

- 객체는 힙, 대부분 구조화되지 않은 메모리 영역에 할당된다. 변수와 객체에 대한 모든 메모리 할당이 여기서 발생한다. (제한적인 공간이다)

```jsx
let presentBox_01_3B = { c: "Iphone13" };
```

Ex ) 선물 상자에 아이폰이 담겨 있고, 이 상자를 집의 선반에 보관했다고 한다면,

이 선물상자를 보관한 선반이 **메모리 힙** 이고 참조형 데이터들이 저장되어 있는 공간이라 할 수 있다.

변수 `presentBox_01_3B` 는 선물상자를 다시 선반에서 찾기 위해 라벨링을 했다고 볼 수 있다.

<br/>

> <h2> 호출스택(Call Stack)

- 자바스크립트는 **단일 스레드** 프로그래밍 언어다. 그래서 **단일 호출 스택**이 있다.
- 단일 호출 스택이란 한번에 하나의 일만 처리한다는 것이다.
- 호출 스택은 프로그램에서 우리가 어디에 있는지를 기본적으로 기록하는 데이터 구조다.
- 실행방식

  1. 함수를 시행
  2. 함수의 기록을 스택 맨위에 추가
  3. 함수 결과 값이 리턴되면 스택에 쌓여있던 함수의 기록이 제거 된다.

  ### 예시로 확인해보자!

  ```jsx
  function sum(a, b) {
    return a * b;
  }

  function count(x) {
    return sum(x, x + 1);
  }

  function consoleCount(y) {
    let counted = count(y);
    console.log(counted);
  }

  consoleCount(5);
  ```

  ### 1 )

    <img width="610" alt="image" src="https://user-images.githubusercontent.com/82592845/181214730-048d72de-0718-4c7d-b42f-6f08345f995d.png">
    
    
    - 호출 스택에 익명(anonymous) 함수가 등록된다. ( 익명 상태로 이름이 없는 상태다 )
    
    ### 2)
    
    <img width="608" alt="image" src="https://user-images.githubusercontent.com/82592845/181214766-0cef5f03-48d7-4a48-957c-7616a6ecc0fc.png">
    
    - `consoleCount` 함수 실행으로 콜스택 상단에 등록됐고, 매개변수 y는 전달인자를 통해 4 가 할당 됐다.
    
    ### 3)
    
    <img width="609" alt="image" src="https://user-images.githubusercontent.com/82592845/181214796-86b8c1d9-d8b5-45a7-90f5-4ed64af20fe9.png">
    
    - `count` 함수가 실행되고 콜스택 상단에 등록된다.
    
    ### 4)
    
    <img width="610" alt="image" src="https://user-images.githubusercontent.com/82592845/181214856-37620bad-25b5-4a86-92fe-a13dc44e5740.png">
    
    - `sum` 함수가 콜스택 최상단을 차지한다.
    
    ### 5)
    
    <img width="609" alt="image" src="https://user-images.githubusercontent.com/82592845/181214903-ebc5d12b-d3c3-4dca-a1dd-d10acab081a0.png">
    
    - 5 + 6 = 11   ⇒  값을 반환한다.
    
    ### 6)
    
    <img width="607" alt="image" src="https://user-images.githubusercontent.com/82592845/181214945-f6edcecc-0159-40cf-900b-eca097669ccc.png">
    
    - `sum` 이 실행됐고 값을 반환했으니 콜스택 에서 소멸된다.
    
    ### 7)
    
    <img width="608" alt="image" src="https://user-images.githubusercontent.com/82592845/181214977-e67b3431-f380-4db4-9d6c-80e2c70dcb32.png">
    
    - `count` 함수도 `consoleCount` 를 통해 실행이 됐기에 소멸된다.
    
    ### 8)
    
    - 마지막으로 console.log(counted) ⇒ 11 을 출력하고consoleCount도 호출스택에서 사라진다

### 위와 같이 호출스택(콜스택)이 작동하는 것을 볼 수 있다.

⇒ 이 과정을 통해 자바스크립트는 싱글 쓰레드 언어라는것을 알 수 있다.

<br/>

# 그렇다면 **스택 오버플로우**는 뭘까?

- 콜스택의 공간은 무한하지 않다. 그렇기에 이 사이즈를 초과 한다면 오류가 발생한다!
- 아래와 같이 자기 자신을 다시 호출해 작업을 수행하는 재귀함수에서 이런 문제가 자주 발생한다.

```jsx
function myNameIs() {
  myNameIs();
}

myNameIs();
```

- `Maximum call stack size exceeded` 라는 오류가 출력된다.

---

( 참조 - [링크](https://velog.io/@milkyway/%EB%A9%94%EB%AA%A8%EB%A6%AC-%ED%9E%99heap%EA%B3%BC-%EC%BD%9C%EC%8A%A4%ED%83%9DCall-stack) 1 , [링크](https://new93helloworld.tistory.com/358) 2, [**링크**](https://runcoding.tistory.com/10) 3)
